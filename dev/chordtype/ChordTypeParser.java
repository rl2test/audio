package audio.chords.parser.chordtype;

import static audio.Constants.BR;
import static audio.Constants.DATA_DIR;
import static audio.Constants.NL;
import static audio.Constants.PIPE_DELIM;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import audio.Util;

/**
 * This class uses the chord definitions in 
 * 		C:\rob\apps\audio\data\chordTypes 
 * to generate 'chordTypes.html' and 'intervalsToAbc.txt' (the latter is  
 * generated by cutting and pasting debug output and then manually editing).
 * 
 * 'chordTypes.html' is used to analyze chord definitions from various sources
 * in the DATA_DIR/chordTypes folder.
 */
public class ChordTypeParser {
	/** The log. */
	private Logger log 							= Logger.getLogger(getClass());
	/** Map of 'chordTypes' using intervalStr as key. */
	private Map<String, ChordType> chordTypes 	= new HashMap<String, ChordType>();
	/** Sorted list of intervalStrs used as keys to 'chordTypes' map. */
	private List<String> intervalStrs			= new ArrayList<String>();
	private final File CHORD_TYPES_DIR			= new File(DATA_DIR, "chordTypes");
	private final String[] fileNames = {
			"guitarCodex",
			"beginnersApproach",
			"chordSymbols",
			"commonChordModifiers",
			"jazzChordSymbols",
			"youCanTeachYourself",
			"ultimateGuitar",
			// TODO
			//"gigBagBook", 
			//"timeToPlayJazz",
	}; 
	
	public void run() {
		log.debug("begin");
		
		List<File> files = new ArrayList<File>();
		for (String fileName: fileNames) {
			files.add(new File(CHORD_TYPES_DIR, fileName + ".txt"));
		}
		
		String[] colors = {
				"00f",
				"0c0",
				"f00",
				"088",
				"880",
				"f0f",
				"80f",
				"8f0",
				"f80",
		};
		int count = 0;
				
		parseChordTypes(files);
		
		File htmlFile = new File(DATA_DIR, "chordTypes.html"); 	

		Collections.sort(intervalStrs);
		
		//Map<String, String> intervalStrToAbcSymbolMap = getIntervalStrToAbcSymbolMap();
		
		StringBuffer html = new StringBuffer();
		
		html.append("<html>" + NL);
		html.append("<head>" + NL);
		html.append("	<title>Untitled</title>" + NL);
		html.append("<style type='text/css'>" + NL);
		html.append("	body 		{font	: normal 8pt verdana, arial, sans-serif;}" + NL);
		html.append("	td	 		{font	: normal 8pt verdana, arial, sans-serif;}" + NL);
		html.append("   table.data {" + NL);
		html.append("		border-collapse: collapse;" + NL);
		html.append("	}");
		html.append("	table.data tr th {" + NL);
		html.append("	 	background-color : #88f;" + NL);
		html.append("	    border		: 1px solid #ccc;" + NL);
		html.append("		padding		: 3px;" + NL);
		html.append("	    font		: bold 8pt verdana, arial, sans-serif;" + NL);
		html.append("	    white-space	: nowrap;" + NL);
		html.append("	}" + NL);
		html.append("	table.data tr td {" + NL);
		html.append("		font	: normal 8pt verdana, arial, sans-serif;" + NL);
		html.append("		border	: 1px solid #ccc;" + NL);
		html.append("		padding	: 3px;" + NL);
		html.append("	}" + NL);
		count = 0;
		for (File file: files) {
			html.append("	span." + getCss(file) + " {color: #" + colors[count++] + ";}" + NL);
		}
		html.append("	span.gray {color: #888;}" + NL);
		html.append("</style>" + NL);
		html.append("</head>" + NL);
		html.append("<body>" + NL);
		
		for (File file: files) {
			html.append("<span class='" + getCss(file) + "'>" + file.getName() + "</span>" + BR + NL);
		}
		
		html.append("<table border='1' class='data'>" + NL);
		html.append("<tr valign='top'>" + NL);
		html.append("<th></td>" + NL);
		html.append("<th>intervalStr</th>" + NL);
		html.append("<th>abcSymbol</th>" + NL);
		html.append("<th>symbols</th>" + NL);
		html.append("<th>descs</th>" + NL);
		html.append("</tr>" + NL);
		count = 1;
		for (String intervalStr: intervalStrs) {
			ChordType chordType = chordTypes.get(intervalStr);
			//String abcSymbol = intervalStrToAbcSymbolMap.get(intervalStr);
			//html.append(chordType.toHtml(count, abcSymbol));
			html.append(chordType.toHtml(count, ""));
			count++;
		}
		html.append("</table>" + NL);

		for (File file: files) {
			html.append("<span class='" + getCss(file) + "'>" + file.getName() + "</span>" + BR + NL);
		}
		
		html.append("</body>" + NL);
		html.append("</html>" + NL);

		Util.writeToFile(htmlFile, html.toString(), false, false);
		
		// Each symbol should map to one and only one intervalStr. There may be
		// multiple symbols mapping to the same intervalStr. For each intervalStr
		// there should be one and only one abcSymbol.
		// 
		// symbol1 --|
		// symbol2 --|--> intervalStr -> abcSymbol
		// symbol3 --|
		/*
		Map<String, String> symbolToIntervalStrMap = new HashMap<String, String>();
		for (String intervalStr: intervalStrs) {
			// check abcSymbol
			String abcSymbol = intervalStrToAbcSymbolMap.get(intervalStr);
			if (symbolToIntervalStrMap.containsKey(abcSymbol)) {
				if (!symbolToIntervalStrMap.get(abcSymbol).equals(intervalStr)) {
					log.error(abcSymbol + " -> " + intervalStr + " existing intervalStr=" + symbolToIntervalStrMap.get(abcSymbol));	
				}
			} else {
				symbolToIntervalStrMap.put(abcSymbol, intervalStr);
			}
			
			// chordType symbol vals
			ChordType chordType = chordTypes.get(intervalStr);
			for (Symbol symbol: chordType.symbols) {
				String symbolVal = symbol.val;
				if (symbolToIntervalStrMap.containsKey(symbolVal)) {
					if (!symbolToIntervalStrMap.get(symbolVal).equals(intervalStr)) {
						log.error(symbolVal + " -> " + intervalStr + " existing intervalStr=" + symbolToIntervalStrMap.get(symbolVal));	
					}
				} else {
					symbolToIntervalStrMap.put(symbolVal, intervalStr);
				}
			}
		}
		*/

		/*
		// generate debug output - intervalStr, symbolStr, firstSymbol - used
		// to generate C:/rob/apps/audio/data/intervalsToAbc.txt file 
		int maxIntervalStr = 0;
		int maxSymbolStr = 0;
		
		List<String> symbolVals = new ArrayList<String>();
		List<String> symbolStrs = new ArrayList<String>();
		for (String intervalStr: intervalStrs) {
			if (intervalStr.length() > maxIntervalStr) {
				maxIntervalStr = intervalStr.length(); 
			}
			symbolVals.clear();
			ChordType chordType = chordTypes.get(intervalStr);
			
			String symbolStr = "";
			for (Symbol symbol: chordType.symbols) {
				String val = symbol.val;
				if (!symbolVals.contains(val)) {
					symbolVals.add(val);
					symbolStr += symbol.val + ", ";
				}
			}
			symbolStr = symbolStr.substring(0, symbolStr.length() - 2);
			symbolStrs.add(symbolStr);
			if (symbolStr.length() > maxSymbolStr) {
				maxSymbolStr = symbolStr.length(); 
			}
		}
		count = 0;
		for (String intervalStr: intervalStrs) {
			String symbolStr = symbolStrs.get(count);
			String firstSymbol = (symbolStr.contains(",")) 
					? symbolStr.substring(0, symbolStr.indexOf(","))
					: symbolStr;
			log.debug(
					Util.padWithSpaces((count + 1) + "", 2) + " | " +
					Util.padWithSpaces(intervalStr, maxIntervalStr) + " | " + 
					Util.padWithSpaces(symbolStr, maxSymbolStr) + " | " +
					firstSymbol);
			count++;
		}
		*/
	}
		
	
	/**
	 * Parse chordTypes
	 */
	private void parseChordTypes(List<File> files) {
		for (File file: files) {
			String src = getCss(file);
		
			List<String> lines = Util.getLines(file);

			for (String line: lines) {
				line = line.trim();
				
				if (line.startsWith("//")) {
					continue;
				}

				//major 7              |maj7, ma7, delta, delta7, M7 |1 3 5 7     
				String[] arr = line.split(PIPE_DELIM);
				
				String descStr 		= arr[0].trim();
				String symbolStr 	= arr[1].trim();
				String intervalStr 	= arr[2].trim();

				ChordType chordType = null;
				
				if (chordTypes.containsKey(intervalStr)) {
					chordType = chordTypes.get(intervalStr);
				} else {
					intervalStrs.add(intervalStr);
					chordType = new ChordType(intervalStr);
					chordTypes.put(intervalStr, chordType);
				}
				
				// in some cases there are multiple desc, symbol definitions per chord
				String[] symbols	= symbolStr.split(",");
				String[] descs 		= descStr.split(",");
				for (String symbol: symbols) {
					chordType.symbols.add(new Symbol(src, symbol.trim()));	
				}
				for (String desc: descs) {
					chordType.descs.add(new Desc(src, desc.trim()));	
				}
			}			
		}
	}
	
	/**
	 * ex. beginnersApproach.txt -> beginnersApproach
	 * 
	 * @param file
	 * @return
	 */
	private String getCss(File file) {
		return file.getName().replace(".txt", "");
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		new ChordTypeParser().run();
	}

}
